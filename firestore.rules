rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function isSignedIn() {
      return request.auth != null;
    }
    // Pair id is two UIDs sorted and joined by underscore
    function isPairMember(pairId) {
      return isSignedIn() && (
        request.auth.uid == pairId.split('_')[0] ||
        request.auth.uid == pairId.split('_')[1]
      );
    }

    // links: shared pair documents
    match /links/{pairId} {
      allow read, write: if isPairMember(pairId) && request.resource.data.keys().hasOnly(["a","b","linked","randomPoseId","updatedAt","schemaVersion"]);

      // Subcollections: game, stats, plans
      match /plans/{docId} {
        allow read, write: if isPairMember(pairId) && request.resource.data.keys().hasOnly(["poses","time","place","status","notes","updatedAt","schemaVersion"]);
      }
      match /game/{docId} {
        allow read, write: if isPairMember(pairId) && request.resource.data.keys().hasOnly(["active","startTime","streak","currentPoseIndex","updatedAt","schemaVersion"]);
      }
      match /stats/{docId} {
        allow read, write: if isPairMember(pairId) && request.resource.data.keys().hasOnly(["totalPosesTried","bestStreak","longestSessionMs","lastSessionEndedAt","updatedAt","schemaVersion"]);
      }
      match /rtc/{docId} { // for optional webrtc signaling messages
        allow read, write: if isPairMember(pairId);
      }
      match /rtc_candidates/{docId} {
        allow read, write: if isPairMember(pairId) && request.resource.data.keys().hasOnly(["c","ts"]);
      }
    }

    // Per-user lists: lists/{uid}/items/{poseId}
    match /lists/{uid}/items/{poseId} {
      allow read: if isSignedIn() && (request.auth.uid == uid);
      allow write: if isSignedIn() && (request.auth.uid == uid) && request.resource.data.keys().hasOnly(["poseId","lists","updatedAt","schemaVersion"]);
    }
  }
}

